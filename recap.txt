CPP_00
	ex00
		decouverte bibliotheque <iostream>
		std::cout  << "..." << std::endl
		str.length()
		std::toupper() et syntaxe cast 

	ex01
		std::getline(std::cin, line);
		creation des classes(private/public)
		std::setw(10) -> formater largeur tableau
		str.substr(0, 9) + '.' -> reduire nombre caracteres pour affichage
		encapsulation (attributs en private accessibles depuis methodes get et set publiques)
		tableau statique (contacts[8]) donc pas d'alloc dynamique

	ex02
		bibliotheque <ctime> recuperation date/heure :
				time_t now = time(NULL);
				tm *ltm = gmtime(&now);
				std::cout << "[" << 1900 + ltm->tm_year << ... << "] ";
		variables statiques a declarer dans le .cpp

CPP_01
	ex00
		utilisation 
			constructeur : Permet d'initialiser un objet avec valeur(s) spÃ©cifique(s) dÃ¨s sa crÃ©ation
			destructeur : Detruit un objet a la fin de l'execution du programme
		allocation  automatique : Zombie z("Bob")
		allocation dynamique : Zombie* z = newZombie("Bob")
			> cree un objet durable accessible via son adresse pointee par z.
			> le detruire manuellement (delete z) lorsqu'on en a plus besoin
		si un zombie est cree dans une fonction de facon automatique il est detruit lorsqu'on sortira de cette fonction

	ex01
		allocation dynamique de tableau d'objet : horde = new Zombie[N];
			> alloue N zombies avec le constructeur par defaut (aucune info sur les zombies renseignees(pas de nom,...))
			> le detruire manuellement (delete[] Zombie) lorsqu'on en a plus besoin

	ex02
		pointeur : adresse dâ€™une variable et peut Ãªtre redirigÃ© vers une autre ou Ãªtre nul (nullptr),
					mais nÃ©cessite un dÃ©rÃ©fÃ©rencement (*ptr) pour accÃ©der Ã  la valeur.
		reference : alias constant vers une variable existante.
					Elle ne peut pas Ãªtre changÃ©e pour viser autre chose, ni Ãªtre null.
					(permet de crÃ©er un deuxiÃ¨me nom pour une mÃªme variable 
					si la valeur de cette variable est modifiÃ©e via lâ€™un des deux noms,
					le changement est visible par lâ€™autre Ã©galement.)

	ex03
		implementer des classes avec des attributs  passes par references ou pointeurs
		Si l'attribut est passe par reference, sa valeur doit etre initialisee lors de la construction ( une ref ne peut pas etre nulle)
		Si l'attribut est passe par pointeur, sa valeur n'a pas besoin d'etre initialisee lors de la construction et peut donc etre nulle

	ex04
		bibliotheque <fstream> pour lecture/ecriture d'objets
		std::ifstream inputFile(argv[1]); -> CrÃ©ation dâ€™un objet inputFile permettant de lire le fichier indiquÃ© par argv[1]
			-> xx.is_open() : vÃ©rifie si le fichier a bien Ã©tÃ© ouvert avec succÃ¨s. Ne vÃ©rifie pas sâ€™il est en bon Ã©tat ou lisible, juste sâ€™il est ouvert
			-> xx.good() : vÃ©rifie si le flux de fichier est dans un Ã©tat valide.
		std::ofstream outputFile(file_replace.c_str()); (file_replace = nom de l'objet a creer)
			-> crÃ©e un objet outputFile de type std::ofstream (fichier de sortie) ouvert en Ã©criture dans le fichier dont le nom est contenu dans la variable file_replace.
			-> file_replace.c_str() caste std::string en const char * car ofstream prend en parametre ce dernier type
		fermer manuellement les objets en lecture/ecriture avant de terminer le programme (inputFile.close() et outputFile.close())
		verifier si l'objet a ouvrir n'est pas un dossier avec bibibliotheque <sys/stat.h>:
			stat(path, &path_stat) remplit la structure path_stat avec des infos sur le fichier ou dossier pointÃ© par path.
			S_ISDIR(path_stat.st_mode) vÃ©rifie si lâ€™Ã©lÃ©ment dÃ©signÃ© est un rÃ©pertoire (dossier).

	ex05
		CrÃ©ation dâ€™un tableau de pointeurs sur mÃ©thodes membres :
			-> syntaxe â†’ [type de retour] (NomClasse::*)([arguments])
			-> exemple â†’ void (Harl::*functions[])()
		ParamÃ¨tres passÃ©s : les adresses des mÃ©thodes membres Ã  appeler, sous la forme :
			-> { &NomClasse::methode1, &NomClasse::methode2, ... }

	ex06
		outil switch case default
			-> switch (int ou char) - case [1,2,3,...,a,b,c,...]: Permet de tester une variable entiÃ¨re (souvent int ou char) contre plusieurs valeurs prÃ©cises.
			-> break : essentiel pour Ã©viter lâ€™effet de â€œchuteâ€ (fallthrough). Sans break, le programme exÃ©cute aussi tous les case suivants, mÃªme si leur condition ne correspond pas.
			-> default : Bloc exÃ©cutÃ© si aucun case ne correspond

CPP_02
	ex00
		utilisation Forme canonique
			-> constructeur par defaut : Initialise un objet sans argument, souvent avec une valeur neutre ou par dÃ©faut.
			-> constructeur par copie : CrÃ©e un nouvel objet en copiant proprement un autre, champ par champ.
			-> Assignation par operateur de copie (=) : Permet de copier le contenu dâ€™un objet vers un autre dÃ©jÃ  existant, tout en Ã©vitant les fuites mÃ©moire ou effets indÃ©sirables.
			-> destructeur : LibÃ¨re proprement les ressources (sâ€™il y en a) Ã  la destruction de lâ€™objet.

	ex01
		manipulation de bit pour stockage/transformation des float - prÃ©cision 1/256 pour float(32 bits)
			-> int : decalage de 8 bits bruts ( 8 zeros vers la gauche) (_rawBits = entier << 8)
			-> float : on decale les bits de 8 positions et on arrondi (par exemple partie entiere : 110100101 - partie decimale :10010011 apres decalage 11010010110010011) (_rawBits = roundf(flotant * 256));
		assignation d'un attribut constant dans le .cpp

	ex02
		surcharges d'operateurs

	ex03
		Exercice d'application des notions du module.
		Objectif de l'exercice : trouver un point dans un triangle.

CPP_03
	ex00
		Mise en situation des tous les exercices prÃ©cÃ©dents
			forme canonique
			methodes
			setters
			getters

	ex01
		ğŸ§¬ HÃ©ritage
			class ScavTrap : public ClapTrap
			ScavTrap hÃ©rite des attributs et mÃ©thodes publiques/protÃ©gÃ©es de ClapTrap.
				â€¢	Lors de la construction, ClapTrap est construit en premier, puis ScavTrap.
				â€¢	Pour garantir une destruction correcte via un pointeur de base, le destructeur de ClapTrap doit Ãªtre virtual.
		ğŸ§  Polymorphisme dynamique
			Une mÃ©thode marquÃ©e virtual permet dâ€™Ãªtre surchargÃ©e dans les classes enfants,
			et le programme appelle automatiquement la version la plus dÃ©rivÃ©e Ã  lâ€™exÃ©cution.
				â€¢	La mÃ©thode peut Ãªtre dÃ©clarÃ©e virtual dans le parent, mÃªme si elle nâ€™est pas encore dÃ©finie.
				â€¢	Cela permet de manipuler des objets enfants via des pointeurs ou rÃ©fÃ©rences de classe de base tout en conservant leur comportement propre.

	ex02
		Idem ex01, on cree une seconde classe FragTrap qui hÃ©rite de ClapTrap mais avec des fonctionnalitÃ©s diffÃ©rentes de ScavTrap

	ex03
		HÃ©ritage multiple
			class DiamondTrap : public ScavTrap, public FragTrap
			DiamondTrap hÃ©rite deux fois indirectement de ClapTrap (via ScavTrap et FragTrap), ce qui crÃ©e une ambiguÃ¯tÃ© sur les membres hÃ©ritÃ©s.
			Cela oblige Ã  spÃ©cifier le chemin dâ€™accÃ¨s pour Ã©viter les collisions :
				ScavTrap::attack(target);

CPP_04
	ex00
		hÃ©ritage et polymorphisme dynamique pour que la fonction makesound soit adaptÃ©e a la bonne instance d'animal.
		effet de l'utilisation de virtual avec la classe wronganimal qui n'utilise pas volontairement void
			resultat, la fonction de la classe animal et directement utilisÃ© donc les dÃ©clarations de cette fonction dans les enfants n'est pas appelÃ© et utilisÃ©e.

	ex01
		utilisation d'une classe (brain) en attributs d'une autre classe
		initialisation et implÃ©mentation de celle-ci 

	ex02
		Lâ€™exercice montre comment intÃ©grer une classe (Brain) comme attribut non-pointeur dans une autre (Dog, Cat)
		et comment gÃ©rer proprement sa construction, destruction et copie, notamment via la forme canonique.
		Brain est composÃ©e dans chaque Dog ou Cat :
			appeler son constructeur dans le constructeur du Dog ou Cat
			gÃ©rer sa copie profonde dans le constructeur de copie et lâ€™opÃ©rateur dâ€™affectation
			gÃ©rer la mÃ©moire (delete)
			bien respecter lâ€™ordre de construction/destruction

	ex03
		