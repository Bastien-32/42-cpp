CPP_00
	ex00
		decouverte bibliotheque <iostream>
		std::cout  << "..." << std::endl
		str.length()
		std::toupper() et syntaxe cast 

	ex01
		std::getline(std::cin, line);
		creation des classes(private/public)
		std::setw(10) -> formater largeur tableau
		str.substr(0, 9) + '.' -> reduire nombre caracteres pour affichage
		encapsulation (attributs en private accessibles depuis methodes get et set publiques)
		tableau statique (contacts[8]) donc pas d'alloc dynamique

	ex02
		bibliotheque <ctime> recuperation date/heure :
				time_t now = time(NULL);
				tm *ltm = gmtime(&now);
				std::cout << "[" << 1900 + ltm->tm_year << ... << "] ";
		variables statiques a declarer dans le .cpp

CPP_01
	ex00
		utilisation 
			constructeur : Permet d'initialiser un objet avec valeur(s) sp√©cifique(s) d√®s sa cr√©ation
			destructeur : Detruit un objet a la fin de l'execution du programme
		allocation  automatique : Zombie z("Bob")
		allocation dynamique : Zombie* z = newZombie("Bob")
			> cree un objet durable accessible via son adresse pointee par z.
			> le detruire manuellement (delete z) lorsqu'on en a plus besoin
		si un zombie est cree dans une fonction de facon automatique il est detruit lorsqu'on sortira de cette fonction

	ex01
		allocation dynamique de tableau d'objet : horde = new Zombie[N];
			> alloue N zombies avec le constructeur par defaut (aucune info sur les zombies renseignees(pas de nom,...))
			> le detruire manuellement (delete[] Zombie) lorsqu'on en a plus besoin

	ex02
		pointeur : adresse d‚Äôune variable et peut √™tre redirig√© vers une autre ou √™tre nul (nullptr),
					mais n√©cessite un d√©r√©f√©rencement (*ptr) pour acc√©der √† la valeur.
		reference : alias constant vers une variable existante.
					Elle ne peut pas √™tre chang√©e pour viser autre chose, ni √™tre null.
					(permet de cr√©er un deuxi√®me nom pour une m√™me variable 
					si la valeur de cette variable est modifi√©e via l‚Äôun des deux noms,
					le changement est visible par l‚Äôautre √©galement.)

	ex03
		implementer des classes avec des attributs  passes par references ou pointeurs
		Si l'attribut est passe par reference, sa valeur doit etre initialisee lors de la construction ( une ref ne peut pas etre nulle)
		Si l'attribut est passe par pointeur, sa valeur n'a pas besoin d'etre initialisee lors de la construction et peut donc etre nulle

	ex04
		bibliotheque <fstream> pour lecture/ecriture d'objets
		std::ifstream inputFile(argv[1]); -> Cr√©ation d‚Äôun objet inputFile permettant de lire le fichier indiqu√© par argv[1]
			-> xx.is_open() : v√©rifie si le fichier a bien √©t√© ouvert avec succ√®s. Ne v√©rifie pas s‚Äôil est en bon √©tat ou lisible, juste s‚Äôil est ouvert
			-> xx.good() : v√©rifie si le flux de fichier est dans un √©tat valide.
		std::ofstream outputFile(file_replace.c_str()); (file_replace = nom de l'objet a creer)
			-> cr√©e un objet outputFile de type std::ofstream (fichier de sortie) ouvert en √©criture dans le fichier dont le nom est contenu dans la variable file_replace.
			-> file_replace.c_str() caste std::string en const char * car ofstream prend en parametre ce dernier type
		fermer manuellement les objets en lecture/ecriture avant de terminer le programme (inputFile.close() et outputFile.close())
		verifier si l'objet a ouvrir n'est pas un dossier avec bibibliotheque <sys/stat.h>:
			stat(path, &path_stat) remplit la structure path_stat avec des infos sur le fichier ou dossier point√© par path.
			S_ISDIR(path_stat.st_mode) v√©rifie si l‚Äô√©l√©ment d√©sign√© est un r√©pertoire (dossier).

	ex05
		Cr√©ation d‚Äôun tableau de pointeurs sur m√©thodes membres :
			-> syntaxe ‚Üí [type de retour] (NomClasse::*)([arguments])
			-> exemple ‚Üí void (Harl::*functions[])()
		Param√®tres pass√©s : les adresses des m√©thodes membres √† appeler, sous la forme :
			-> { &NomClasse::methode1, &NomClasse::methode2, ... }

	ex06
		outil switch case default
			-> switch (int ou char) - case [1,2,3,...,a,b,c,...]: Permet de tester une variable enti√®re (souvent int ou char) contre plusieurs valeurs pr√©cises.
			-> break : essentiel pour √©viter l‚Äôeffet de ‚Äúchute‚Äù (fallthrough). Sans break, le programme ex√©cute aussi tous les case suivants, m√™me si leur condition ne correspond pas.
			-> default : Bloc ex√©cut√© si aucun case ne correspond

CPP_02
	ex00
		utilisation Forme canonique
			-> constructeur par defaut : Initialise un objet sans argument, souvent avec une valeur neutre ou par d√©faut.
			-> constructeur par copie : Cr√©e un nouvel objet en copiant proprement un autre, champ par champ.
			-> Assignation par operateur de copie (=) : Permet de copier le contenu d‚Äôun objet vers un autre d√©j√† existant, tout en √©vitant les fuites m√©moire ou effets ind√©sirables.
			-> destructeur : Lib√®re proprement les ressources (s‚Äôil y en a) √† la destruction de l‚Äôobjet.

	ex01
		manipulation de bit pour stockage/transformation des float - pr√©cision 1/256 pour float(32 bits)
			-> int : decalage de 8 bits bruts ( 8 zeros vers la gauche) (_rawBits = entier << 8)
			-> float : on decale les bits de 8 positions et on arrondi (par exemple partie entiere : 110100101 - partie decimale :10010011 apres decalage 11010010110010011) (_rawBits = roundf(flotant * 256));
		assignation d'un attribut constant dans le .cpp

	ex02
		surcharges d'operateurs

	ex03
		Exercice d'application des notions du module.
		Objectif de l'exercice : trouver un point dans un triangle.

CPP_03
	ex00
		Mise en situation des tous les exercices pr√©c√©dents
			forme canonique
			methodes
			setters
			getters

	ex01
		üß¨ H√©ritage
			class ScavTrap : public ClapTrap
			ScavTrap h√©rite des attributs et m√©thodes publiques/prot√©g√©es de ClapTrap.
				‚Ä¢	Lors de la construction, ClapTrap est construit en premier, puis ScavTrap.
				‚Ä¢	Pour garantir une destruction correcte via un pointeur de base, le destructeur de ClapTrap doit √™tre virtual.
		üß† Polymorphisme dynamique
			Une m√©thode marqu√©e virtual permet d‚Äô√™tre surcharg√©e dans les classes enfants,
			et le programme appelle automatiquement la version la plus d√©riv√©e √† l‚Äôex√©cution.
				‚Ä¢	La m√©thode peut √™tre d√©clar√©e virtual dans le parent, m√™me si elle n‚Äôest pas encore d√©finie.
				‚Ä¢	Cela permet de manipuler des objets enfants via des pointeurs ou r√©f√©rences de classe de base tout en conservant leur comportement propre.

	ex02
		Idem ex01, on cree une seconde classe FragTrap qui h√©rite de ClapTrap mais avec des fonctionnalit√©s diff√©rentes de ScavTrap

	ex03
		H√©ritage multiple
			class DiamondTrap : public ScavTrap, public FragTrap
			DiamondTrap h√©rite deux fois indirectement de ClapTrap (via ScavTrap et FragTrap), ce qui cr√©e une ambigu√Øt√© sur les membres h√©rit√©s.
			Cela oblige √† sp√©cifier le chemin d‚Äôacc√®s pour √©viter les collisions :
				ScavTrap::attack(target);

CPP_04
	ex00
		h√©ritage et polymorphisme dynamique pour que la fonction makesound soit adapt√©e a la bonne instance d'animal.
		effet de l'utilisation de virtual avec la classe wronganimal qui n'utilise pas volontairement void
			resultat, la fonction de la classe animal et directement utilis√© donc les d√©clarations de cette fonction dans les enfants n'est pas appel√© et utilis√©e.

	ex01
		utilisation d'une classe (brain) en attributs d'une autre classe
		initialisation et impl√©mentation de celle-ci 

	ex02
		Notion de classe abstraite
		L‚Äôexercice montre comment int√©grer une classe (Brain) comme attribut non-pointeur dans une autre (Dog, Cat)
		et comment g√©rer proprement sa construction, destruction et copie, notamment via la forme canonique.
		Brain est compos√©e dans chaque Dog ou Cat :
			appeler son constructeur dans le constructeur du Dog ou Cat
			g√©rer sa copie profonde dans le constructeur de copie et l‚Äôop√©rateur d‚Äôaffectation
			g√©rer la m√©moire (delete)
			bien respecter l‚Äôordre de construction/destruction

	ex03
		Notion de classes purements abstraites : l'interface
			Tous les √©l√©ments sont des m√©thodes virtuelles pures d√©clar√©es en virtual ... = 0;
			Seules ses classes d√©riv√©es peuvent √™tre utilis√©es et elles doivent obligatoirement impl√©menter toutes ses m√©thodes.

CPP_05
	ex00
		Apprendre √† cr√©er une classe avec des valeurs contraintes et √† g√©rer les erreurs avec des exceptions personnalis√©es.
		Permet d‚Äôafficher une erreur sans utiliser de return ou de bool√©ens, en g√©rant proprement l‚Äôexception 
		Creation d'une classe dans un classe (.hpp):
			class GradeTooHighException : public std::exception {
			public:
				const char* what() const throw();};

		Declaratin de la m√©thode(pi√®ces sp√©cifi√© toutes les classes  dans lesquelles elle se trouve) :
			const char* Bureaucrat::GradeTooHighException::what() const throw()
			{
				return ("Grade is too high!");
			}

		Exemple d'appel √† une exception :
			if (_grade < 1)
				throw GradeTooHighException();

		Exemple de test √† effectuer. On teste la fonction si √ßa fonctionne √ßa sort sinon √ßa applique les particularit√©s du catch:
			try
			{
				Bureaucrat b("Jean", 0); // Exception ici
			}
			catch (const std::exception& e)
			{
				std::cerr << e.what() << std::endl;
			}

	ex01
		‚Ä¢	Une classe peut agir sur une autre
			‚Üí Ici : Bureaucrat agit sur un Form via la m√©thode beSigned(Bureaucrat&).
		‚Ä¢	Gestion d‚Äôerreur √† l‚Äôint√©rieur d‚Äôune m√©thode via throw
			‚Üí Si le grade du bureaucrate est trop bas, beSigned() lance une exception.
			‚Üí C‚Äôest ensuite au code appelant de g√©rer l‚Äôexception avec try / catch.
		‚Ä¢	Structure multi-classe :
			‚Ä¢	Chaque .cpp n‚Äôa besoin que de l‚Äô#include du .hpp des classes qu‚Äôil utilise
			‚Ä¢	Bien g√©rer les inclusions crois√©es (ex : #include "Bureaucrat.hpp" dans form.cpp et "class Bureaucrat;" dans Form.hpp)
		‚Ä¢	Attributs constants (const)
			‚Üí Doivent √™tre initialis√©s dans le constructeur, jamais modifi√©s ensuite.

	ex02
		Cr√©ation de formulaires h√©ritants la classe form transform√©e en Aform car la m√©thode execute est abstraite pour que les m√©thodes enfants aient leurs propres ex√©cution de cette m√©thode
		V√©rification des conditions d'ex√©cution du formulaire : grade suffisant + sign√©

	ex03
		Continuit√© de l'apprentissage des tableaux sur pointeurs de m√©thodes
			√âvite l'usage de if/else √† foison
		Attention, les m√©thodes doivent appartenir √† la classe dans laquelle on utilise le tableau sur pointeur.
		Il faut donc cr√©er les m√©thodes n√©cessaires pour ex√©cuter des m√©thodes d√©clar√©s dans d'autres classes.

CPP_06
	ex00
		apprentissage des casts : static_cast<T>(d)
		pr√©cision des d√©cimales dans les float et doubles : std::cout << std::fixed << std::setprecision(1);
		utilisation des fonctions std::stoi,stof,stdod pour convertir une string en int, float ou double
		d√©finition de scalaire : 
			‚Ä¢	Un scalaire est une valeur simple, √† une dimension, par opposition √† un vecteur, une matrice, une structure, etc.
			‚Ä¢	En C++, on appelle types scalaires : char, int, float, double (mais aussi bool, nullptr_t, les pointeurs, etc.).
		Ici, le but est de convertir un scalaire d‚Äôun type √† un autre (par exemple : "42" ‚Üí char ' * ', int 42, float 42.0f, double 42.0).

	ex01
		uintptr_t
			‚ÄÉ‚Üí Type entier non sign√© capable de contenir une adresse m√©moire.
			‚ÄÉ‚Üí Permet de convertir un pointeur en entier brut (ex. pour s√©rialisation/transmission).
		reinterpret_cast<T>(ptr)
			‚ÄÉ‚Üí Cast bas niveau pour convertir entre types tr√®s diff√©rents (ex. Data* ‚Üî uintptr_t).
			‚ÄÉ‚Üí ‚ö†Ô∏è √Ä utiliser avec pr√©caution (aucune v√©rification √† la compilation).
		S√©rialisation de pointeur
			‚ÄÉ‚Üí Un pointeur ne peut pas √™tre √©crit/lu/transmis proprement.
			‚ÄÉ‚Üí En le convertissant en entier (uintptr_t), il devient manipulable comme une valeur.
		Classe non instanciable
			‚ÄÉ‚Üí En rendant le constructeur priv√©, on emp√™che toute cr√©ation d‚Äôobjet de la classe.

	ex02
		G√©n√©ration al√©atoire d‚Äôune classe h√©rit√©e (A, B ou C)
		Identification via pointeur :
			‚Üí dynamic_cast<Classe*>(ptr)
			‚Üí Testable avec if car retourne nullptr si le cast √©choue
		Identification via r√©f√©rence :
			‚Üí dynamic_cast<Classe&>(ref)
			‚Üí Une r√©f√©rence ne pouvant √™tre null, le cast ne peut pas √™tre test√© avec if
			‚Üí N√©cessite un try/catch car un cast invalide d√©clenche une exception

CPP_07
	ex00
		::min(x, y)
			‚ÄÉ‚Üí force l‚Äôappel √† la fonction globale min,
			‚ÄÉ‚ÄÉ√©vite les conflits avec std::min ou d‚Äôautres min() locaux.
		template <typename T>
			‚ÄÉ‚Üí √† placer avant chaque fonction template,
			‚ÄÉ‚ÄÉsert √† d√©clarer un type g√©n√©rique utilis√© dans la fonction.
		T remplace un type r√©el au moment de l‚Äôappel.
			‚ÄÉ‚Üí √©vite de dupliquer la fonction pour chaque type.
			‚ÄÉ‚Üí tous les param√®tres doivent √™tre du m√™me type (m√™me T).

	ex01
		Une fonction template peut prendre une fonction en param√®tre :
	‚ÄÉ		‚Üí type : void (*f)(T&) ou void (*f)(const T&).
		Les fonctions templates peuvent √™tre surcharg√©es :
			‚ÄÉ‚Üí ici, deux versions de iter n√©cessaires pour g√©rer T& et const T&.
		Les templates fonctionnent aussi avec des fonctions pass√©es en pointeurs (callback).
		Le compilateur instancie le template selon la signature exacte de la fonction pass√©e :
			‚ÄÉ‚Üí iter avec T& ‚â† iter avec const T&.

	ex02
		ecrire une classe g√©n√©rique via template <typename T>
		surcharge d'opertateur []
		manipulation new[] / delete[]

CPP_08
	ex00
		container ? boite qui peut contenir des donnees de differents types
			1. vector (<vector>)
				Stocke les donnees comme dans un tableau.
				On implemente le containeur avec push_back(|value|),
				on ne peut donc rajouter des donnees qu'a la fin du tableau (push_front impossible)
				On peut acceder aux donnees par indices
			2. liste chainee (<list>)
				Stocke les donnees comme dans une liste.
				On implemente le containeur avec push_back(|value|) ou push_front(|value|),
				On ne peut pas acceder aux donnees par indices
			3. deque (<deque>) (file double)
				Combine les avantages du tableau et de la liste.
				On impl√©mente le conteneur avec push_back(|value|) ou push_front(|value|),
				Mais aussi ajouter et retirer des √©l√©ments au d√©but comme dans une list.
				On peut acc√©der aux donn√©es par indices comme dans un vector,
		syntaxe : std::vector<int>::iterator	it; (main)
			std::vector<int> -> type de conteneur qu'on veut parcourir
			::iterator -> type d‚Äôit√©rateur associ√© √† ce conteneur
			it -> nom de la variable
		syntaxe : typename T::iterator	easyfind(T& container, int value) (.hpp)
			typename T::iterator -> type d‚Äôit√©rateur associ√© au conteneur g√©n√©rique T
				- typename est obligatoire pour dire au compilateur que c‚Äôest un "type d√©pendant"
				- T est un conteneur (ex : std::vector<int>, std::list<int>, etc.)
				- T::iterator est le type utilis√© pour le parcourir
			easyfind -> nom de la fonction template
			(T& container, int value) -> arguments :
				- container : une r√©f√©rence vers un conteneur g√©n√©rique de type T
				- value : la valeur enti√®re √† chercher dans ce conteneur
		bibliotheque <stdexcept> introduit la fonction std::runtime_error
	ex01
		
