CPP_00
	ex00
		decouverte bibliotheque <iostream>
		std::cout  << "..." << std::endl
		str.length()
		std::toupper() et syntaxe cast 

	ex01
		std::getline(std::cin, line);
		creation des classes(private/public)
		std::setw(10) -> formater largeur tableau
		str.substr(0, 9) + '.' -> reduire nombre caracteres pour affichage
		encapsulation (attributs en private accessibles depuis methodes get et set publiques)
		tableau statique (contacts[8]) donc pas d'alloc dynamique

	ex02
		bibliotheque <ctime> recuperation date/heure :
				time_t now = time(NULL);
				tm *ltm = gmtime(&now);
				std::cout << "[" << 1900 + ltm->tm_year << ... << "] ";
		variables statiques a declarer dans le .cpp

CPP_01
	ex00
		utilisation 
			constructeur : Permet d'initialiser un objet avec valeur(s) spÃ©cifique(s) dÃ¨s sa crÃ©ation
			destructeur : Detruit un objet a la fin de l'execution du programme
		allocation  automatique : Zombie z("Bob")
		allocation dynamique : Zombie* z = newZombie("Bob")
			> cree un objet durable accessible via son adresse pointee par z.
			> le detruire manuellement (delete z) lorsqu'on en a plus besoin
		si un zombie est cree dans une fonction de facon automatique il est detruit lorsqu'on sortira de cette fonction

	ex01
		allocation dynamique de tableau d'objet : horde = new Zombie[N];
			> alloue N zombies avec le constructeur par defaut (aucune info sur les zombies renseignees(pas de nom,...))
			> le detruire manuellement (delete[] Zombie) lorsqu'on en a plus besoin

	ex02
		pointeur : adresse dâ€™une variable et peut Ãªtre redirigÃ© vers une autre ou Ãªtre nul (nullptr),
					mais nÃ©cessite un dÃ©rÃ©fÃ©rencement (*ptr) pour accÃ©der Ã  la valeur.
		reference : alias constant vers une variable existante.
					Elle ne peut pas Ãªtre changÃ©e pour viser autre chose, ni Ãªtre null.
					(permet de crÃ©er un deuxiÃ¨me nom pour une mÃªme variable 
					si la valeur de cette variable est modifiÃ©e via lâ€™un des deux noms,
					le changement est visible par lâ€™autre Ã©galement.)

	ex03
		implementer des classes avec des attributs  passes par references ou pointeurs
		Si l'attribut est passe par reference, sa valeur doit etre initialisee lors de la construction ( une ref ne peut pas etre nulle)
		Si l'attribut est passe par pointeur, sa valeur n'a pas besoin d'etre initialisee lors de la construction et peut donc etre nulle

	ex04
		bibliotheque <fstream> pour lecture/ecriture d'objets
		std::ifstream inputFile(argv[1]); -> CrÃ©ation dâ€™un objet inputFile permettant de lire le fichier indiquÃ© par argv[1]
			-> xx.is_open() : vÃ©rifie si le fichier a bien Ã©tÃ© ouvert avec succÃ¨s. Ne vÃ©rifie pas sâ€™il est en bon Ã©tat ou lisible, juste sâ€™il est ouvert
			-> xx.good() : vÃ©rifie si le flux de fichier est dans un Ã©tat valide.
		std::ofstream outputFile(file_replace.c_str()); (file_replace = nom de l'objet a creer)
			-> crÃ©e un objet outputFile de type std::ofstream (fichier de sortie) ouvert en Ã©criture dans le fichier dont le nom est contenu dans la variable file_replace.
			-> file_replace.c_str() caste std::string en const char * car ofstream prend en parametre ce dernier type
		fermer manuellement les objets en lecture/ecriture avant de terminer le programme (inputFile.close() et outputFile.close())
		verifier si l'objet a ouvrir n'est pas un dossier avec bibibliotheque <sys/stat.h>:
			stat(path, &path_stat) remplit la structure path_stat avec des infos sur le fichier ou dossier pointÃ© par path.
			S_ISDIR(path_stat.st_mode) vÃ©rifie si lâ€™Ã©lÃ©ment dÃ©signÃ© est un rÃ©pertoire (dossier).

	ex05
		CrÃ©ation dâ€™un tableau de pointeurs sur mÃ©thodes membres :
			-> syntaxe â†’ [type de retour] (NomClasse::*)([arguments])
			-> exemple â†’ void (Harl::*functions[])()
		ParamÃ¨tres passÃ©s : les adresses des mÃ©thodes membres Ã  appeler, sous la forme :
			-> { &NomClasse::methode1, &NomClasse::methode2, ... }

	ex06
		outil switch case default
			-> switch (int ou char) - case [1,2,3,...,a,b,c,...]: Permet de tester une variable entiÃ¨re (souvent int ou char) contre plusieurs valeurs prÃ©cises.
			-> break : essentiel pour Ã©viter lâ€™effet de â€œchuteâ€ (fallthrough). Sans break, le programme exÃ©cute aussi tous les case suivants, mÃªme si leur condition ne correspond pas.
			-> default : Bloc exÃ©cutÃ© si aucun case ne correspond

CPP_02
	ex00
		utilisation Forme canonique
			-> constructeur par defaut : Initialise un objet sans argument, souvent avec une valeur neutre ou par dÃ©faut.
			-> constructeur par copie : CrÃ©e un nouvel objet en copiant proprement un autre, champ par champ.
			-> Assignation par operateur de copie (=) : Permet de copier le contenu dâ€™un objet vers un autre dÃ©jÃ  existant, tout en Ã©vitant les fuites mÃ©moire ou effets indÃ©sirables.
			-> destructeur : LibÃ¨re proprement les ressources (sâ€™il y en a) Ã  la destruction de lâ€™objet.

	ex01
		manipulation de bit pour stockage/transformation des float - prÃ©cision 1/256 pour float(32 bits)
			-> int : decalage de 8 bits bruts ( 8 zeros vers la gauche) (_rawBits = entier << 8)
			-> float : on decale les bits de 8 positions et on arrondi (par exemple partie entiere : 110100101 - partie decimale :10010011 apres decalage 11010010110010011) (_rawBits = roundf(flotant * 256));
		assignation d'un attribut constant dans le .cpp

	ex02
		surcharges d'operateurs

	ex03
		Exercice d'application des notions du module.
		Objectif de l'exercice : trouver un point dans un triangle.

CPP_03
	ex00
		Mise en situation des tous les exercices prÃ©cÃ©dents
			forme canonique
			methodes
			setters
			getters

	ex01
		ğŸ§¬ HÃ©ritage
			class ScavTrap : public ClapTrap
			ScavTrap hÃ©rite des attributs et mÃ©thodes publiques/protÃ©gÃ©es de ClapTrap.
				â€¢	Lors de la construction, ClapTrap est construit en premier, puis ScavTrap.
				â€¢	Pour garantir une destruction correcte via un pointeur de base, le destructeur de ClapTrap doit Ãªtre virtual.
		ğŸ§  Polymorphisme dynamique
			Une mÃ©thode marquÃ©e virtual permet dâ€™Ãªtre surchargÃ©e dans les classes enfants,
			et le programme appelle automatiquement la version la plus dÃ©rivÃ©e Ã  lâ€™exÃ©cution.
				â€¢	La mÃ©thode peut Ãªtre dÃ©clarÃ©e virtual dans le parent, mÃªme si elle nâ€™est pas encore dÃ©finie.
				â€¢	Cela permet de manipuler des objets enfants via des pointeurs ou rÃ©fÃ©rences de classe de base tout en conservant leur comportement propre.

	ex02
		Idem ex01, on cree une seconde classe FragTrap qui hÃ©rite de ClapTrap mais avec des fonctionnalitÃ©s diffÃ©rentes de ScavTrap

	ex03
		HÃ©ritage multiple
			class DiamondTrap : public ScavTrap, public FragTrap
			DiamondTrap hÃ©rite deux fois indirectement de ClapTrap (via ScavTrap et FragTrap), ce qui crÃ©e une ambiguÃ¯tÃ© sur les membres hÃ©ritÃ©s.
			Cela oblige Ã  spÃ©cifier le chemin dâ€™accÃ¨s pour Ã©viter les collisions :
				ScavTrap::attack(target);

CPP_04
	ex00
		hÃ©ritage et polymorphisme dynamique pour que la fonction makesound soit adaptÃ©e a la bonne instance d'animal.
		effet de l'utilisation de virtual avec la classe wronganimal qui n'utilise pas volontairement void
			resultat, la fonction de la classe animal et directement utilisÃ© donc les dÃ©clarations de cette fonction dans les enfants n'est pas appelÃ© et utilisÃ©e.

	ex01
		utilisation d'une classe (brain) en attributs d'une autre classe
		initialisation et implÃ©mentation de celle-ci 

	ex02
		Notion de classe abstraite
		Lâ€™exercice montre comment intÃ©grer une classe (Brain) comme attribut non-pointeur dans une autre (Dog, Cat)
		et comment gÃ©rer proprement sa construction, destruction et copie, notamment via la forme canonique.
		Brain est composÃ©e dans chaque Dog ou Cat :
			appeler son constructeur dans le constructeur du Dog ou Cat
			gÃ©rer sa copie profonde dans le constructeur de copie et lâ€™opÃ©rateur dâ€™affectation
			gÃ©rer la mÃ©moire (delete)
			bien respecter lâ€™ordre de construction/destruction

	ex03
		Notion de classes purements abstraites : l'interface
			Tous les Ã©lÃ©ments sont des mÃ©thodes virtuelles pures dÃ©clarÃ©es en virtual ... = 0;
			Seules ses classes dÃ©rivÃ©es peuvent Ãªtre utilisÃ©es et elles doivent obligatoirement implÃ©menter toutes ses mÃ©thodes.

CPP_05
	ex00
		Apprendre Ã  crÃ©er une classe avec des valeurs contraintes et Ã  gÃ©rer les erreurs avec des exceptions personnalisÃ©es.
		Permet dâ€™afficher une erreur sans utiliser de return ou de boolÃ©ens, en gÃ©rant proprement lâ€™exception 
		Creation d'une classe dans un classe (.hpp):
			class GradeTooHighException : public std::exception {
			public:
				const char* what() const throw();};

		Declaratin de la mÃ©thode(piÃ¨ces spÃ©cifiÃ© toutes les classes  dans lesquelles elle se trouve) :
			const char* Bureaucrat::GradeTooHighException::what() const throw()
			{
				return ("Grade is too high!");
			}

		Exemple d'appel Ã  une exception :
			if (_grade < 1)
				throw GradeTooHighException();

		Exemple de test Ã  effectuer. On teste la fonction si Ã§a fonctionne Ã§a sort sinon Ã§a applique les particularitÃ©s du catch:
			try
			{
				Bureaucrat b("Jean", 0); // Exception ici
			}
			catch (const std::exception& e)
			{
				std::cerr << e.what() << std::endl;
			}

	ex01
		â€¢	Une classe peut agir sur une autre
			â†’ Ici : Bureaucrat agit sur un Form via la mÃ©thode beSigned(Bureaucrat&).
		â€¢	Gestion dâ€™erreur Ã  lâ€™intÃ©rieur dâ€™une mÃ©thode via throw
			â†’ Si le grade du bureaucrate est trop bas, beSigned() lance une exception.
			â†’ Câ€™est ensuite au code appelant de gÃ©rer lâ€™exception avec try / catch.
		â€¢	Structure multi-classe :
			â€¢	Chaque .cpp nâ€™a besoin que de lâ€™#include du .hpp des classes quâ€™il utilise
			â€¢	Bien gÃ©rer les inclusions croisÃ©es (ex : #include "Bureaucrat.hpp" dans form.cpp et "class Bureaucrat;" dans Form.hpp)
		â€¢	Attributs constants (const)
			â†’ Doivent Ãªtre initialisÃ©s dans le constructeur, jamais modifiÃ©s ensuite.

	ex02
		CrÃ©ation de formulaires hÃ©ritants la classe form transformÃ©e en Aform car la mÃ©thode execute est abstraite pour que les mÃ©thodes enfants aient leurs propres exÃ©cution de cette mÃ©thode
		VÃ©rification des conditions d'exÃ©cution du formulaire : grade suffisant + signÃ©

	ex03
		ContinuitÃ© de l'apprentissage des tableaux sur pointeurs de mÃ©thodes
			Ã‰vite l'usage de if/else Ã  foison
		Attention, les mÃ©thodes doivent appartenir Ã  la classe dans laquelle on utilise le tableau sur pointeur.
		Il faut donc crÃ©er les mÃ©thodes nÃ©cessaires pour exÃ©cuter des mÃ©thodes dÃ©clarÃ©s dans d'autres classes.

CPP_06
	ex00
		apprentissage des casts : static_cast<T>(d)
		prÃ©cision des dÃ©cimales dans les float et doubles : std::cout << std::fixed << std::setprecision(1);
		utilisation des fonctions std::stoi,stof,stdod pour convertir une string en int, float ou double
		dÃ©finition de scalaire : 
			â€¢	Un scalaire est une valeur simple, Ã  une dimension, par opposition Ã  un vecteur, une matrice, une structure, etc.
			â€¢	En C++, on appelle types scalaires : char, int, float, double (mais aussi bool, nullptr_t, les pointeurs, etc.).
		Ici, le but est de convertir un scalaire dâ€™un type Ã  un autre (par exemple : "42" â†’ char ' * ', int 42, float 42.0f, double 42.0).

	ex01
		uintptr_t
			â€ƒâ†’ Type entier non signÃ© capable de contenir une adresse mÃ©moire.
			â€ƒâ†’ Permet de convertir un pointeur en entier brut (ex. pour sÃ©rialisation/transmission).
		reinterpret_cast<T>(ptr)
			â€ƒâ†’ Cast bas niveau pour convertir entre types trÃ¨s diffÃ©rents (ex. Data* â†” uintptr_t).
			â€ƒâ†’ âš ï¸ Ã€ utiliser avec prÃ©caution (aucune vÃ©rification Ã  la compilation).
		SÃ©rialisation de pointeur
			â€ƒâ†’ Un pointeur ne peut pas Ãªtre Ã©crit/lu/transmis proprement.
			â€ƒâ†’ En le convertissant en entier (uintptr_t), il devient manipulable comme une valeur.
		Classe non instanciable
			â€ƒâ†’ En rendant le constructeur privÃ©, on empÃªche toute crÃ©ation dâ€™objet de la classe.

	ex02
		GÃ©nÃ©ration alÃ©atoire dâ€™une classe hÃ©ritÃ©e (A, B ou C)
		Identification via pointeur :
			â†’ dynamic_cast<Classe*>(ptr)
			â†’ Testable avec if car retourne nullptr si le cast Ã©choue
		Identification via rÃ©fÃ©rence :
			â†’ dynamic_cast<Classe&>(ref)
			â†’ Une rÃ©fÃ©rence ne pouvant Ãªtre null, le cast ne peut pas Ãªtre testÃ© avec if
			â†’ NÃ©cessite un try/catch car un cast invalide dÃ©clenche une exception

CPP_07
	ex00
		::min(x, y)
			â€ƒâ†’ force lâ€™appel Ã  la fonction globale min,
			â€ƒâ€ƒÃ©vite les conflits avec std::min ou dâ€™autres min() locaux.
		template <typename T>
			â€ƒâ†’ Ã  placer avant chaque fonction template,
			â€ƒâ€ƒsert Ã  dÃ©clarer un type gÃ©nÃ©rique utilisÃ© dans la fonction.
		T remplace un type rÃ©el au moment de lâ€™appel.
			â€ƒâ†’ Ã©vite de dupliquer la fonction pour chaque type.
			â€ƒâ†’ tous les paramÃ¨tres doivent Ãªtre du mÃªme type (mÃªme T).

	ex01
		Une fonction template peut prendre une fonction en paramÃ¨tre :
	â€ƒ		â†’ type : void (*f)(T&) ou void (*f)(const T&).
		Les fonctions templates peuvent Ãªtre surchargÃ©es :
			â€ƒâ†’ ici, deux versions de iter nÃ©cessaires pour gÃ©rer T& et const T&.
		Les templates fonctionnent aussi avec des fonctions passÃ©es en pointeurs (callback).
		Le compilateur instancie le template selon la signature exacte de la fonction passÃ©e :
			â€ƒâ†’ iter avec T& â‰  iter avec const T&.

	ex02
		ecrire une classe gÃ©nÃ©rique via template <typename T>
		surcharge d'opertateur []
		manipulation new[] / delete[]

CPP_08
	ex00
		container ? boite qui peut contenir des donnees de differents types
			1. vector (<vector>)
				Stocke les donnees comme dans un tableau.
				On implemente le containeur avec push_back(|value|),
				on ne peut donc rajouter des donnees qu'a la fin du tableau (push_front impossible)
				On peut acceder aux donnees par indices
			2. liste chainee (<list>)
				Stocke les donnees comme dans une liste.
				On implemente le containeur avec push_back(|value|) ou push_front(|value|),
				On ne peut pas acceder aux donnees par indices
			3. deque (<deque>) (file double)
				Combine les avantages du tableau et de la liste.
				On implÃ©mente le conteneur avec push_back(|value|) ou push_front(|value|),
				Mais aussi ajouter et retirer des Ã©lÃ©ments au dÃ©but comme dans une list.
				On peut accÃ©der aux donnÃ©es par indices comme dans un vector,
		syntaxe : std::vector<int>::iterator	it; (main)
			std::vector<int> -> type de conteneur qu'on veut parcourir
			::iterator -> type dâ€™itÃ©rateur associÃ© Ã  ce conteneur
			it -> nom de la variable
		syntaxe : typename T::iterator	easyfind(T& container, int value) (.hpp)
			typename T::iterator -> type dâ€™itÃ©rateur associÃ© au conteneur gÃ©nÃ©rique T
				- typename est obligatoire pour dire au compilateur que câ€™est un "type dÃ©pendant"
				- T est un conteneur (ex : std::vector<int>, std::list<int>, etc.)
				- T::iterator est le type utilisÃ© pour le parcourir
			easyfind -> nom de la fonction template
			(T& container, int value) -> arguments :
				- container : une rÃ©fÃ©rence vers un conteneur gÃ©nÃ©rique de type T
				- value : la valeur entiÃ¨re Ã  chercher dans ce conteneur
		bibliotheque <stdexcept> introduit la fonction std::runtime_error
	ex01
		
